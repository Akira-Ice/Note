### 基础数据类型 「primitive value」

| 基础类型      | 值                                  |
|:--------- |:---------------------------------- |
| Boolean   | 只有两个值：`true` 与 `false`             |
| Null      | 只有一个值：`null`                       |
| Undefined | 只有一个值：`undefined`                  |
| Number    | 所有数字                               |
| String    | 所有字符串                              |
| Symbol    | 符号类型 `var sym = Symbol('tSymbol')` |
| BigInt    | 整数的末尾追加 n                          |

**重点**

- **基础数据类型是值，是不可改变的**
- **基础数据类型，是按值访问的**
- **基础数据类型也能访问方法**

```javascript
var str = 'hello world'
str[0] = 'K' // 试图修改字符串的第一个字符

console.log(str) // 打印结果：hello world
```

> 使用括号访问字符串不可以对其进行删除或添加，因为字符串对应未知的属性并不是可读或配置的。

```js
var str = 'hello world'
str.charAt(0)
```

基础数据类型变量上的`CharAt`方法从何而来🤔

实际上Javascript中，对每一种基础数据类型，都提供对应的包装对象。所以在实际访问的时候，会先进行包装对象，然后就可以调用对象实例上的方法

```js
// 首先使用包装对象创建对象
var _str = new String('hello world')

// 然后使用包装对象的实例去访问方法
_str.charAt(0)

// 最后销毁该对象
_str = null
```

#### 引用数据类型「reference value」

**重点**

- **引用数据类型的值是可以被改变的**
- **引用数据类型，是按引用访问的**

```js
const book = {
  title: 'JavaScript 核心进阶',
  author: '这波能反杀',
  date: '2020.08.02'
}
const b2 = book;
b2.author = '反杀';
console.log(book); // {title: "JavaScript 核心进阶", author: "反杀", date: "2020.08.02"}
console.log(b2);   // {title: "JavaScript 核心进阶", author: "反杀", date: "2020.08.02"}
```

![](https://images.xiaozhuanlan.com/photo/2020/57dc4944a62a178282158e28f5e1bd38.png)

`b2 = book`并非像基础数据类型一样，值的本身有一份新的拷贝，而是对地址的拷贝。这种拷贝地址的操作，也被称为**浅拷贝**

由于操作的是同一地址下的数据，所以 b2 的修改，同时也能修改原 book 

因此我们说，**引用数据类型，是按引用访问的**，这里的引用就是值内存中地址的引用

相同两个引用类型在比较时，本质上也是，他们在内存上的比较

同理，这种引用地址的比较，也叫被称为**浅比较**

> 浅拷贝与浅比较，都是针对引用数据类型的概念，它们没有非常明确的界限来定义，在其他场景里，只比较一层数据结构，也被认为是浅比较，浅比较是低成本的比较方式，浅拷贝同理。

### 内存

| 对象  | 容量  | 访问速度 | CPU能否直接访问 | 存储时效  |
|:--- |:--- |:---- |:--------- |:----- |
| 内存  | 小   | 快    | 能         | 程序运行时 |
| 硬盘  | 大   | 慢    | 不能        | 持久性   |

在 Javascript 中，内存分为 栈内存、堆内存。本身没有区别，存取方式有差异

- 栈内存：从高位开始分配内存空间
- 堆内存：从地位开始分配内存空间

![](https://images.xiaozhuanlan.com/photo/2020/40693a2c35caa0de813352e71544311b.png)

### 基础数据结构

**栈、堆、队列** 

#### 栈「stack」

![](https://images.xiaozhuanlan.com/photo/2020/450d9258c8c99bf9c9c1ba3c84428ad4.png)

**先进后出，后进先出（LIFO，Last In，First Out）**

在 Javascript 中，通过 Array 实现存储：

**push**：向数组末尾添加元素「进栈方法」
push 方法可以接受任意参数，把他们逐个添加到数组末尾，并返回修改后数组的长度

```javascript
var a = [];
a.push(1); // a: [1]
a.push(2, 4, 6); // a: [1, 2, 4, 6]
var l = a.push(5); // a: [1, 2, 4, 6, 5] l: 5
```

**pop**：弹出数据最末尾的一个元素「出栈方法」
pop方法会将数据最末尾的一个元素删除，并返回被删除的元素。

```javascript
var a = [1, 2, 3];
a.pop(); // a: [1, 2]
// a.pop()的返回结果为 3
```

**函数调用栈「call Stack」：**栈内存空间，用于记录函数的执行记录，代表函数的执行顺序

#### 堆「heap」

堆内存，与堆数据结构是完全不同的两回事

堆内存是内存中的空间区域。CPU 可以通过内存地址直接访问

它的存取方式与在书架中取书的方式非常相似

下面是示意图⬇️

![](https://images.xiaozhuanlan.com/photo/2020/6505ca50858c7876eb0e6aa1f6da1722.png)

用对象形式体现：

```js
let testHeap = {
    a: 10,
  b: 20,
  c: {
    m: 100,
    n: 110
  }
}
```

堆数据结构，是一种特殊的树状结构。他们关系大概如下：

![](https://images.xiaozhuanlan.com/photo/2020/b1ab9a0312b92974091aeba2c63c67d7.png)

而为了易于存储与索引，在实践中，我们常常会使用二叉堆去解决问题。例如，在 v8 定时器实现原理中，我们会使用二叉堆「又称**优先级队列**」来决定哪个事件优先执行

> 优先级队列是非常重要的知识，高级前端工程师必备

二叉堆是一颗完全二叉树

![](https://images.xiaozhuanlan.com/photo/2020/aa5abcb1114996c88a55c7dbb743e2d9.png)

二叉堆又分最大堆和最小堆。

**最大堆**，又称大顶堆，父节点的键值总是大于等于任何一个子节点。
**最小堆**，又称小顶堆，父节点的键值总是小于等于任何一个子节点。

#### 队列「queue」

队列是一种先进先出（FIFO）的数据结构

![](https://images.xiaozhuanlan.com/photo/2020/98a601e5b91c069e7f573823f275d8db.png)

### 内存空间管理

`新个体参与运行 -> 分配空间 -> 运行结束 -> 释放空间`

对于栈内存而言，操作系统会自动回收出栈的内存空间。

对于堆内存而言，JavaScript 中提供了自动的垃圾回收机制，来释放内存。

垃圾回收主要依靠「引用」的概念。当一块内存空间中的数据能够被访问时，垃圾回收器就认为「该数据能够被获得」，也就意味着，这份数据可能还需要使用。不能够被获得的数据，就会被打上标记，并释放对应的内存空间。这种方式叫做**标记-清除算法**。

这个算法会设置一个全局对象，并定期的从全局对象开始查找，垃圾回收器将会找到所有可以获得与不能够被获得的数据。

**注意：**垃圾回收无法判断全局声明的内存什么时候释放，因此开发过程中避免使用 var ，或者采用赋值 null 方式，进行释放引用，便于回收
